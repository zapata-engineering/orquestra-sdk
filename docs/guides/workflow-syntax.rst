.. only:: internal

    Note: the plan for this doc is to eventually add it to the internal docs, e.g. add the end of the `Workflow guide <https://github.com/zapatacomputing/orquestra-docs2/blob/45657442bee3df7b63164033e1ce53533a4bfd9b/developer/guides/workflows.rst>`_.


=============================
``@workflow`` function syntax
=============================

Orquestra Workflow SDK lets you define your workflow as a regular Python function.
Under the hood, the SDK turns it into a computational graph.
There are some limitations to what's possible to process automatically, not every valid Python function is a valid workflow function.


What's supported in a workflow function
=======================================

Invoking tasks defined in the same module
-----------------------------------------

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def same_module():
    :end-before: </snippet>
    :language: python
    :dedent: 8


Invoking tasks defined in another module
----------------------------------------

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def define_task_in_other_module():
    :end-before: </snippet>
    :language: python
    :dedent: 8

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def import_task_from_other_module():
    :end-before: </snippet>
    :language: python
    :dedent: 8


Passing outputs from one task as inputs to another one
------------------------------------------------------

.. note::
    A variable that holds task output is called internally ``ArtifactFuture``.
    If you get an error that contains the word ``ArtifactFuture``, chances are something went wrong with parsing the workflow function.

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def passing_outputs():
    :end-before: </snippet>
    :language: python
    :dedent: 8



Returning workflow outputs
--------------------------

This designates some of the workflow variables to be returned via ``orq get workflow-run-results``.
The computational graph generated by the SDK will include all the task invocations required to compute these values.
It has to be a list of task outputs or constants defined within workflow:

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def returning_values():
    :end-before: </snippet>
    :language: python
    :dedent: 8


Fixed literals inside the workflow
----------------------------------

The SDK will embed these values directly in the workflow graph.
Values of simple data types will be serialized using JSON (``str``, ``int``, ``float``, ``dict``, ``list``, ``None``).
Any other data type will be serialized using ``pickle``.

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def fixed_literals():
    :end-before: </snippet>
    :language: python
    :dedent: 8


Invoking regular, non-task functions
------------------------------------

Contrary to tasks, function calls inside workflow function are always executed on your machine, at the time of ``orq submit workflow-def``.
This scenario works, but it's not recommended, so the SDK will print a "not a @task" warning.

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def calling_regular_function():
    :end-before: </snippet>
    :language: python
    :dedent: 8


What doesn't work
=================

This is a list of the gotchas we've seen our users falling for.
Some of these would be very difficult to enable given the underlying system constraints.
Others might be solvable, but might have had low priority.

.. only:: internal

    If you'd really like to use one of these, please let the SDK team know by filling a feature request in the `AHA Idea Portal <https://zapatacomputing.ideas.aha.io/ideas>`_.


Invoking tasks from within tasks
--------------------------------

This is closely related to "dynamic graphs" concept that Orquestra currently doesn't support.

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def task_in_task_fails():
    :end-before: </snippet>
    :language: python
    :dedent: 8

- Workaround: extract common code to plain Python functions and use them from within tasks. Tasks should be only invoked from a workflow function.

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def task_in_task_workaround():
    :end-before: </snippet>
    :language: python
    :dedent: 8


Mixing constants with task outputs
----------------------------------

Although the workflow function looks like a regular Python code, the task outputs are not known until the workflow is executed.
During workflow definition time, tasks return proxy objects called ``ArtifactFuture`` s.

.. literalinclude:: ../examples/tests/test_workflow_syntax.py
    :start-after: def mixing_constants_with_outputs():
    :end-before: </snippet>
    :language: python
    :dedent: 8

- Workaround 1: define your tasks such that inputs and outputs have similar shape.

    .. literalinclude:: ../examples/tests/test_workflow_syntax.py
        :start-after: def mixing_constants_with_outputs_workaround_1():
        :end-before: </snippet>
        :language: python
        :dedent: 8


- Workaround 2: define a separate task that builds the required data structure.

    .. warning::
        Adopting this workaround creates separate nodes in the computational graph only to reshape your data structures.
        Each task invocation has an overhead, and this might waste time, especially when running workflows on Quantum Engine.
        Please try workaround 1 first.

    .. literalinclude:: ../examples/tests/test_workflow_syntax.py
        :start-after: def mixing_constants_with_outputs_workaround_2():
        :end-before: </snippet>
        :language: python
        :dedent: 8
